定义：确保一个类在任何情况下都只有一个实例，并提供一个全局访问点，隐藏其所有的构造方法



ServletContext、ServletConfig、ApplicationContext、DBPool



### 饿汉式单例

在单例类中首次加载的时候就创建实例

加final的意义：避免被人用反射的方法给修改类的属性

缺点：浪费内存空间



### 懒汉式单例

被外部类调用时才创建实例

为啥这里属性定义不加final：因为加了final后就不能在使用的时候实例化了

线程安全问题：方法加锁

在将synchronized关键字加在方法上，不可避免还是存在一些性能问题，可能产生死锁问题

双重检查锁



内部类方式：

LazyHolder里面的逻辑需要等到外部方法调用时才执行，巧妙的利用了内部类的特点

JVM底层执行逻辑，完美的避开了线程安全问题

内部类什么时候加载，内部类里面的方法什么时候加载？？

虽然用JVM避免了线程不安全问题，但是用内部类方式有个缺陷，那就是可以使用反射技术来破坏单例



序列化破坏单例：

解决方法：重写单例类中的readResolve方法

readObject()方法

重写readResolve方法，只不过是覆盖了反序列化的对象而已，其实还是创建了2次，只不过是发生在JVM层面，比较安全，之前反序列化出来的对象会被GC回收

FileInputStream/ObjectInputStream



### 注册式单例

将每一个实例都缓存到容器中，使用唯一的标识来获取实例



枚举实现单例:可以避免序列化问题破坏单例

jad下载地址： https://varaneckas.com/jad/ 

经过反编译，可以看出是饿汉式的，并且是线程安全的

只需要序列化破坏单例，那么是怎么避免的呢？

Enum.valueOf((Class) c1,name)

从JDK层面就为枚举不被序列化和反射保驾护航



Spring中使用的注册式单例

getBean()方法不安全，容器本身是安全的

发令枪



### ThreadLocal单例

线程内安全，线程间不安全，伪单例

ThreadLocalMap存储

使用ThreaLocal实现多数据源动态切换



总结：

1. 私有化构造器
2. 保证线程安全
3. 延迟加载
4. 防止序列化和反序列化破坏
5. 防御反射攻击单例

